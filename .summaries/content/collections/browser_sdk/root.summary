## Amplitude Browser SDK Product Ecosystem

The Amplitude Browser SDK is a comprehensive analytics tracking solution for web applications, offering multiple SDK versions and specialized tools for event tracking, user analytics, and marketing attribution. The ecosystem centers around strongly-typed JavaScript/TypeScript SDKs that integrate with Amplitude's HTTP V2 API for robust web analytics.

## Product Architecture and Relationships

### Core SDK Evolution
The product ecosystem follows a clear evolutionary path with three main SDK generations:

**Legacy JavaScript SDK (amplitude-js)** - The original maintenance-mode SDK that established core patterns like `amplitude.getInstance()`, `logEvent()`, and cookie-based tracking with AMP_ prefixed cookies.

**Browser SDK 1.x (@amplitude/analytics-browser v1)** - The first modern TypeScript implementation introducing HTTP V2 API integration, plugin architecture, and consolidated tracking methods through a unified `track()` API.

**Browser SDK 2.x (@amplitude/analytics-browser v2+)** - The current flagship SDK featuring built-in autocapture functionality, enhanced marketing attribution, server-side user agent parsing, and streamlined configuration options.

### Specialized Extensions
**Marketing Analytics SDK (@amplitude/marketing-analytics-browser)** - A maintenance-mode extension providing automatic UTM parameter tracking, referrer attribution, click ID capture (gclid, fbclid, dclid), and campaign-based session management.

**Browser Unified SDK (@amplitude/unified)** - A beta integration layer providing single initialization for Analytics, Experiment, and Session Replay through the `initAll()` method with shared configuration.

### Code Generation Tools
**Ampli Wrappers** - Strongly-typed API generators available for all SDK versions (JavaScript SDK, Browser SDK 1.0, Browser SDK 2.0) that create type-safe tracking functions from Amplitude Data tracking plans using the Ampli CLI with `ampli pull` and `ampli status` commands.

## Key Nomenclature and Definitions

### Core Tracking Concepts
- **deviceId**: Persistent browser identifier stored in cookies for cross-session tracking
- **sessionId**: Temporary identifier for user session boundaries and analytics grouping
- **userId**: Application-specific user identifier for cross-device user journey tracking
- **Identify**: Interface for managing user properties through operations like set, add, remove
- **Revenue**: Specialized tracking interface for e-commerce and monetization events

### Cookie and Storage Architecture
- **AMP_ prefix**: Standard cookie naming convention using `AMP_{api_key}_{property}` format
- **AMP_MKTG_**: Marketing-specific cookie prefix for attribution data storage
- **identityStorage**: Configurable storage backend (cookies, localStorage, sessionStorage, none)
- **cookieOptions**: Configuration object controlling expiration, security, and cross-domain behavior

### Event Tracking Systems
- **Autocapture**: Built-in automatic tracking for page views, sessions, form interactions, file downloads, element interactions, and network requests
- **defaultTracking**: Configuration object controlling automatic event collection including attribution, pageViews, sessions, formInteractions, fileDownloads
- **trackingOptions**: Granular control over automatic property collection (IP address, user agent, referrer, UTM parameters)

### Plugin Architecture
- **EnrichmentPlugin**: Middleware for modifying events before transmission
- **DestinationPlugin**: Custom endpoints for event routing and processing
- **Plugin Interface**: Extensible system with setup(), execute(), and teardown() lifecycle methods

### Attribution and Marketing
- **UTM parameters**: Campaign tracking parameters (utm_source, utm_medium, utm_campaign, utm_term, utm_content)
- **Click IDs**: Platform-specific identifiers (gclid for Google, fbclid for Facebook, dclid for Display & Video 360)
- **First-touch attribution**: Initial campaign attribution stored as user properties
- **Multi-touch attribution**: Comprehensive campaign journey tracking across sessions

## API Endpoints and Integration Methods

### SDK Initialization Patterns
```javascript
// Browser SDK 2.x
amplitude.init('API_KEY', 'user@example.com', options)

// Unified SDK
initAll('API_KEY', { analytics: {}, experiment: {}, sessionReplay: {} })

// Legacy JavaScript SDK
amplitude.getInstance().init('API_KEY')
```

### Core Tracking Methods
- **track()**: Primary event logging with properties and options
- **identify()**: User property management using Identify interface
- **revenue()**: Monetization tracking with Revenue interface
- **setGroup()**: Organization and cohort assignment
- **flush()**: Manual event queue processing

### Ampli CLI Commands
- **ampli pull**: Downloads strongly-typed tracking functions from Amplitude Data
- **ampli status**: Verifies implementation against tracking plan schema

### Configuration Endpoints
- **serverZone**: Regional data residency (US, EU) for GDPR compliance
- **serverUrl**: Custom endpoint configuration for proxy or enterprise deployments
- **flushIntervalMillis/flushQueueSize**: Batch processing and network optimization

## Broader Ecosystem Integration

### Amplitude Platform Integration
The Browser SDK ecosystem integrates deeply with Amplitude's broader analytics platform through HTTP V2 API endpoints, supporting advanced features like User Privacy API for GDPR/CNIL compliance, DSAR (Data Subject Access Request) API for data portability, and remote configuration for dynamic SDK behavior management.

### Consent Management and Privacy
Comprehensive privacy controls include deferred initialization patterns for consent management platforms (CMP), GDPR compliance through EU server zones and data retention policies, CNIL France exemption handling for analytics cookies, and granular opt-out mechanisms with `setOptOut()` and storage clearing capabilities.

### Migration and Compatibility
The ecosystem provides structured migration paths between SDK versions with detailed breaking change documentation, cookie migration utilities for preserving user identity across upgrades, and compatibility layers for maintaining existing integrations during transitions.

### Development and Deployment
Production deployment support includes Content Security Policy (CSP) compatibility, bundle size optimization through tree-shaking, TypeScript/JavaScript dual compatibility, and integration patterns for popular frameworks, build tools, and tag management systems like Google Tag Manager.