# Amplitude iOS SDK Comparison

## Amplitude-iOS (Maintenance SDK)
- **Technology**: Built with Objective-C
- **Status**: Legacy SDK in maintenance mode (bug fixes only, no new features)
- **Use Case**: Existing applications already using this SDK or Objective-C projects that require backward compatibility
- **Key Limitations**: Lacks modern architecture, plugin system, and newer features
- **Installation**: CocoaPods, Carthage, manual integration
- **Language Support**: Objective-C native, usable in Swift with bridging

## AmplitudeSwift (Current SDK)
- **Technology**: Built with Swift using modern Swift patterns
- **Status**: Actively developed and recommended for new implementations
- **Key Features**:
  - Plugin architecture for extensibility
  - Improved performance and reduced memory footprint
  - Enhanced offline support
  - Middleware support for event transformation
  - Default tracking options (sessions, app lifecycles, deep links)
- **Use Case**: New iOS applications or existing apps ready to migrate to a modern SDK
- **Installation**: Swift Package Manager, CocoaPods, Carthage
- **Language Support**: Swift native, optimized for Swift applications

## Ampli Wrapper
- **Technology**: Code-generated wrapper around AmplitudeSwift
- **Key Features**:
  - Type-safe event tracking based on a tracking plan
  - Compile-time validation of event properties
  - Autocomplete support for events and properties
  - Tracking plan consistency enforcement
- **Use Case**: Teams using Amplitude's Data planning features who want to ensure analytics implementation matches their tracking plan
- **Workflow**: Define tracking plan in Amplitude → Generate Ampli SDK → Implement in code
- **Benefits**: Reduces errors in event tracking, improves developer experience, ensures data quality
- **Requires**: An Amplitude tracking plan and the base AmplitudeSwift SDK

## Amplitude Unified SDK
- **Technology**: Wrapper that combines multiple Amplitude product SDKs
- **Components**: Integrates Analytics (AmplitudeSwift), Experiment (A/B testing), and Session Replay
- **Key Features**:
  - Single initialization for all Amplitude products
  - Shared configuration and identity management
  - Simplified integration when using multiple Amplitude products
- **Use Case**: Applications that need multiple Amplitude capabilities (analytics, experimentation, session replay)
- **Benefits**: Reduces integration complexity, ensures consistent identity across products
- **When to Use**: When you're implementing more than one Amplitude product in your application

## Decision Guide

- **For new applications**: Use AmplitudeSwift for basic analytics or Unified SDK if you need multiple Amplitude products
- **For applications with a tracking plan**: Use Ampli Wrapper to ensure implementation matches specification
- **For existing Amplitude-iOS implementations**: Continue using it if migration cost is high, or plan migration to AmplitudeSwift
- **For A/B testing or feature flags**: Use the Unified SDK to integrate Analytics and Experiment
- **For debugging user experiences**: Use the Unified SDK to integrate Analytics and Session Replay

The SDKs can be viewed as layers of increasing functionality, with AmplitudeSwift as the foundation, Ampli adding type safety, and Unified SDK adding product integration.