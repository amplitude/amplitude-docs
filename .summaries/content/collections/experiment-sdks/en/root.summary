Amplitude Experiment is a comprehensive feature flagging and experimentation platform that provides SDKs across multiple programming languages and platforms for both client-side and server-side implementations. The platform enables developers to implement feature flags, conduct A/B tests, and manage feature rollouts with sophisticated targeting capabilities.

## Product Architecture and Evaluation Modes

The platform operates through two primary evaluation modes:

**Remote Evaluation** uses the `fetch()` method to retrieve variants from Amplitude's servers via API calls, suitable for client-side implementations where real-time flag updates are needed. This mode requires network connectivity and involves API calls to retrieve experiment assignments.

**Local Evaluation** uses the `start()` method to download flag configurations locally and evaluate variants client-side, providing faster performance and offline capability. This mode includes automatic flag configuration polling (controlled by `flagConfigPollingIntervalMillis`) and optional flag streaming (`streamUpdates`) for real-time updates.

The **Evaluation Proxy** serves as a Docker-based intermediary service (`amplitudeinc/evaluation-proxy`) that enables local evaluation on unsupported platforms, running on port 3546 with Redis for persistent storage and automatic assignment event deduplication.

## SDK Ecosystem and Platform Coverage

The platform provides comprehensive SDK coverage across major development platforms:

**Client-side SDKs** include JavaScript (`@amplitude/experiment-js-client`), iOS (CocoaPods/SPM), Android (Maven Central), React Native (`@amplitude/experiment-react-native-client`), and a legacy React Native version in maintenance mode.

**Server-side SDKs** cover JVM (Java/Kotlin), Node.js (`@amplitude/experiment-node-server`), Python (`amplitude-experiment`), Ruby (`amplitude-experiment` gem), PHP (`experiment-php-server`), and Go (`github.com/amplitude/experiment-go-server`).

## Key Nomenclature and Core Concepts

**Deployment Keys** serve as the primary authentication mechanism for SDK initialization, distinguishing between different environments and projects.

**Variants** represent the different experiment treatments or feature flag states that users receive, accessed through the `variant()` method with automatic exposure tracking.

**ExperimentUser** is the standardized user object across all SDKs, containing properties like `device_id`, `user_properties`, and `group_properties` for targeting and evaluation.

**Exposure Tracking** automatically logs when users are exposed to experiments, with customizable providers (`ExposureTrackingProvider`) and 24-hour deduplication in the evaluation proxy.

**Flag Configurations** define the experiment rules and targeting criteria, synchronized locally in local evaluation mode through polling or streaming mechanisms.

## Advanced Targeting and Synchronization

**Cohort Targeting** enables sophisticated user segmentation through `CohortSyncConfig`, requiring analytics API keys and secret keys for synchronization. The system supports hourly cohort sync with configurable `maxCohortSize` parameters.

**Assignment Tracking** provides automatic experiment assignment logging through `AssignmentConfig`, enabling comprehensive experiment analytics and attribution.

**Account-level Bucketing** supports group-based experiments using group properties for B2B use cases and organizational-level feature rollouts.

## Integration Ecosystem

The platform integrates seamlessly with **Amplitude Analytics** through dedicated initialization methods (`initializeWithAmplitudeAnalytics`) that automatically handle user identification and event tracking.

**Third-party Analytics** integrations include Segment, mParticle, and custom analytics providers through standardized provider interfaces.

**Amplitude Cookie Integration** (`AmplitudeCookie`) enables device ID management and user session continuity across web implementations.

## Configuration and Bootstrapping

**Server Zone Configuration** supports both US and EU data centers through `ServerZone` settings, enabling data residency compliance.

**Bootstrapping** capabilities include `initialVariants` and `initialFlags` configuration for immediate variant availability before remote fetching, with `Source.InitialVariants` tracking for attribution.

**Provider Interfaces** include `ExperimentUserProvider` for dynamic user identification and `ExposureTrackingProvider` for custom analytics integration.

## Deployment and Infrastructure

The platform supports various deployment patterns including **Kubernetes Helm charts**, **Docker Compose**, and **Minikube** for the evaluation proxy. Configuration is managed through YAML files with project arrays and environment-specific settings.

**Load Balancer Compatibility** is achieved through stateless proxy deployment, enabling horizontal scaling and high availability configurations.

The system provides comprehensive timeout and retry configurations (`fetchTimeoutMillis`, `fetchRetries`) and supports both synchronous and asynchronous evaluation methods (`fetch_async_v2()`, `CompletableFuture` variants) across different programming paradigms.