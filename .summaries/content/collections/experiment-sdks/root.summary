Amplitude Experiment is a comprehensive feature flagging and experimentation platform that enables developers to implement A/B tests, feature flags, and controlled rollouts across web, mobile, and server environments. The platform provides sophisticated targeting capabilities, real-time configuration updates, and seamless integration with analytics systems.

## Product Architecture and Evaluation Modes

The platform operates through two distinct evaluation architectures:

**Remote Evaluation** leverages the `fetch()` method to retrieve experiment variants from Amplitude's servers via REST API calls. This mode is optimized for client-side implementations requiring real-time flag updates and dynamic configuration changes. Remote evaluation maintains direct connectivity to Amplitude's infrastructure for immediate variant assignment.

**Local Evaluation** utilizes the `start()` method to download complete flag configurations locally, enabling client-side variant evaluation without network dependencies. This architecture provides superior performance through local computation and offline capability. Local evaluation includes automatic flag configuration synchronization via `flagConfigPollingIntervalMillis` and optional real-time streaming through `streamUpdates` for immediate configuration propagation.

The **Evaluation Proxy** functions as a Docker-based intermediary service (`amplitudeinc/evaluation-proxy`) that extends local evaluation capabilities to unsupported platforms. The proxy operates on port 3546, utilizes Redis for persistent storage, and implements automatic assignment event deduplication with 24-hour windows.

## SDK Ecosystem and Platform Coverage

The platform maintains comprehensive SDK coverage across major development ecosystems:

**Client-side SDKs** include JavaScript (`@amplitude/experiment-js-client`), iOS (distributed via CocoaPods and Swift Package Manager), Android (Maven Central distribution), React Native (`@amplitude/experiment-react-native-client`), and a legacy React Native implementation in maintenance mode.

**Server-side SDKs** encompass JVM environments (Java/Kotlin), Node.js (`@amplitude/experiment-node-server`), Python (`amplitude-experiment`), Ruby (`amplitude-experiment` gem), PHP (`experiment-php-server`), and Go (`github.com/amplitude/experiment-go-server`).

## Core Nomenclature and Definitions

**Deployment Keys** serve as the primary authentication and project identification mechanism for SDK initialization, enabling environment-specific configurations and access control.

**Variants** represent distinct experiment treatments or feature flag states delivered to users. Variants are accessed through the `variant()` method, which automatically triggers exposure tracking for analytics attribution.

**ExperimentUser** defines the standardized user object schema across all SDKs, containing essential properties including `device_id`, `user_properties`, and `group_properties` for targeting evaluation and user segmentation.

**Exposure Tracking** automatically logs user interactions with experiments through customizable `ExposureTrackingProvider` implementations. The evaluation proxy implements 24-hour exposure deduplication to prevent duplicate event logging.

**Flag Configurations** contain experiment rules, targeting criteria, and variant definitions. In local evaluation mode, these configurations are synchronized through polling mechanisms or real-time streaming for immediate updates.

## Advanced Targeting and User Segmentation

**Cohort Targeting** enables sophisticated user segmentation through `CohortSyncConfig`, requiring analytics API keys and secret keys for secure synchronization. The system supports configurable hourly cohort synchronization with `maxCohortSize` parameters for performance optimization.

**Assignment Tracking** provides comprehensive experiment assignment logging through `AssignmentConfig`, enabling detailed experiment analytics, attribution analysis, and user journey tracking.

**Account-level Bucketing** supports group-based experimentation using group properties, specifically designed for B2B use cases and organizational-level feature rollouts where individual user targeting is insufficient.

## Integration Architecture

The platform integrates natively with **Amplitude Analytics** through dedicated initialization methods (`initializeWithAmplitudeAnalytics`) that automatically manage user identification, device tracking, and event attribution without additional configuration.

**Third-party Analytics** integrations include standardized provider interfaces for Segment, mParticle, and custom analytics platforms, enabling experiment data to flow into existing analytics infrastructure.

**Amplitude Cookie Integration** (`AmplitudeCookie`) manages device ID persistence and user session continuity across web implementations, ensuring consistent user identification across browser sessions.

## Configuration and Bootstrapping

**Server Zone Configuration** supports both US and EU data centers through `ServerZone` settings, enabling organizations to maintain data residency compliance and optimize network latency.

**Bootstrapping** capabilities include `initialVariants` and `initialFlags` configuration options that provide immediate variant availability before remote configuration fetching completes. The system tracks bootstrap sources through `Source.InitialVariants` for proper attribution.

**Provider Interfaces** include `ExperimentUserProvider` for dynamic user identification and `ExposureTrackingProvider` for custom analytics integration, enabling flexible integration patterns across different application architectures.

## Deployment Infrastructure and Operations

The platform supports multiple deployment patterns including **Kubernetes Helm charts**, **Docker Compose**, and **Minikube** configurations for the evaluation proxy. Infrastructure configuration is managed through YAML files supporting project arrays and environment-specific settings.

**Load Balancer Compatibility** is achieved through stateless proxy deployment architecture, enabling horizontal scaling, high availability configurations, and seamless traffic distribution across multiple proxy instances.

## API Endpoints and Performance Configuration

The system provides comprehensive timeout and retry configurations through `fetchTimeoutMillis` and `fetchRetries` parameters. SDKs support both synchronous and asynchronous evaluation patterns, including `fetch_async_v2()` methods and `CompletableFuture` variants for different programming paradigms and performance requirements.

The evaluation proxy exposes REST endpoints for variant evaluation, flag configuration retrieval, and health monitoring, enabling integration with platforms lacking native SDK support while maintaining the performance benefits of local evaluation.