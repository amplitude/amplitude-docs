## Amplitude React Native SDK

The Amplitude React Native SDK is a comprehensive analytics tracking solution designed for React Native applications, providing strongly typed event tracking capabilities with enterprise-scale features. The SDK ecosystem consists of multiple components that work together to deliver robust analytics implementation with TypeScript support and compile-time validation.

## Product Architecture and Core Components

The SDK ecosystem is built around three primary components that form an integrated analytics solution:

**Current SDK (`@amplitude/analytics-react-native`)** serves as the modern implementation featuring HTTP V2 API support, plugin architecture, and enhanced configuration capabilities. This SDK provides the foundational analytics functionality through three core operations: `init()` for initialization, `track()` for event tracking, and `identify()` for user identification. The architecture requires `@react-native-async-storage/async-storage` for local data persistence and supports both iOS and Android platforms with specific Gradle compatibility requirements.

**Maintenance SDK (`@amplitude/react-native`)** represents the legacy implementation maintained for backward compatibility. This version uses `getInstance()` patterns and older API structures but does not receive new feature development, serving organizations that require stability during migration periods.

**Ampli Wrapper** functions as a code generation layer that creates strongly typed interfaces over either SDK implementation. This component generates APIs directly from Amplitude Data tracking plans, supporting JavaScript ES6 and TypeScript 2.1+ with CJS module packaging. The wrapper enables compile-time validation of event schemas and properties through generated code that maps to defined tracking plans.

## Feature Relationships and Integration Patterns

The relationship between components follows a layered architecture where the Ampli Wrapper provides type safety over the base SDK functionality. The Current SDK offers advanced features including EU data residency through `serverZone` configuration, plugin architecture for extensibility, and enhanced batching controls. Migration capabilities through `migrateLegacyData` enable seamless transitions from the Maintenance SDK, automatically transferring stored user data and device identifiers.

The plugin system creates extensibility points supporting EnrichmentPlugin and DestinationPlugin types for custom data processing and routing to third-party analytics platforms. Custom HTTP clients can be implemented through `transportProvider` customization, enabling proxy configurations or specialized networking requirements.

## Key Nomenclature and Technical Definitions

**Identify Operations**: User property management system utilizing the Identify class with methods including `set()`, `add()`, `remove()`, and `clearAll()` for comprehensive user attribute manipulation.

**Revenue Interface**: Structured e-commerce tracking framework with standardized properties including `price`, `quantity`, `productId`, and `revenueType` for revenue analytics with specialized API endpoint validation.

**Tracking Options**: Configuration object controlling automatic data collection including advertising identifiers (ADID, AppSetId, IDFV, IDFA), location data (`location_lat`, `location_lng`), and device information collection.

**Batching Configuration**: Performance optimization system using `flushQueueSize` and `flushIntervalMillis` parameters to control event transmission timing and volume to Amplitude servers.

**Plugin Architecture**: Extensible framework supporting custom data processing pipelines and third-party integrations through standardized plugin interfaces.

## Ecosystem Integration and Data Flow

The SDK integrates with the broader Amplitude ecosystem through multiple integration points and data routing mechanisms. EU data residency compliance is achieved through `serverZone` configuration that automatically routes data to European servers when required. The HTTP V2 API provides the communication layer with automatic endpoint routing based on configuration settings.

The Ampli CLI provides essential workflow commands for tracking plan management, including `ampli pull` for retrieving latest tracking plans and regenerating typed interfaces, and `ampli status` for validating local implementation against current tracking plans. This integration ensures consistency between defined analytics schemas and implementation code.

Revenue events utilize specialized endpoints within the Amplitude ecosystem for e-commerce tracking with enhanced validation and processing capabilities. The plugin system enables data flow to external analytics platforms and custom processing pipelines while maintaining primary data routing to Amplitude servers.

## Platform-Specific Implementation

**iOS Integration** requires `pod install` for dependency management and supports advertising identifier collection through IDFA and IDFV mechanisms. The SDK handles iOS 16+ deprecation of CTCarrier for carrier information collection, ensuring compatibility across iOS versions.

**Android Implementation** requires adherence to specific Gradle compatibility matrices and supports Google Play Services integration for AppSetId and advertising identifier collection through `play-services-appset` and `play-services-ads-identifier` dependencies.

**Expo Applications** require special consideration for over-the-air (OTA) updates, with specific guidance provided for maintaining analytics continuity during application updates and deployment cycles.

## Migration and API Mapping

The migration framework provides comprehensive mapping between legacy and current SDK implementations, including method transformations from `getInstance().init()` to `init()`, `logEvent()` to `track()`, and configuration object restructuring. This enables seamless upgrades while maintaining analytics data continuity and user identification consistency across SDK versions.

The strongly typed interfaces generated by the Ampli Wrapper provide methods including `ampli.load()`, `ampli.identify()`, and `ampli.track()` that map directly to underlying SDK functionality while adding compile-time validation and improved developer experience through TypeScript integration.