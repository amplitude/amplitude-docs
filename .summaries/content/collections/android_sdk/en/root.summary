# Amplitude Android SDK Product Overview

## Product Overview

Amplitude's Android SDK ecosystem provides analytics tracking capabilities for Android applications, offering two main SDK variants:

1. **Android-Kotlin SDK** (`com.amplitude:analytics-android`) - The latest, actively developed SDK written in Kotlin with modern architecture and enhanced features
2. **Android SDK** (`com.amplitude:android-sdk`) - The legacy SDK in maintenance mode

Both SDKs enable developers to track user events, manage user identities, track revenue, and capture session data in Android applications. The ecosystem also includes the Ampli Wrapper, which provides type-safe event tracking based on predefined tracking plans.

## Product Relationships and Architecture

### Core SDK Components

1. **Android-Kotlin SDK**: The primary, actively developed SDK that offers:
   - Modern Kotlin-based implementation
   - Plugin architecture for extensibility
   - Enhanced autocapture capabilities
   - Improved configuration options
   - HTTP V2 API support

2. **Legacy Android SDK**: The maintenance-mode SDK that provides:
   - Core event tracking functionality
   - User identification
   - Revenue tracking
   - Session management
   - Middleware support

3. **Ampli Wrapper**: A code-generated layer that:
   - Sits on top of either Android SDK
   - Enforces tracking plan schemas
   - Provides type-safe APIs for events and properties
   - Prevents instrumentation errors through compile-time checks

### Integration Flow

The SDKs integrate with the broader Amplitude ecosystem:
1. SDK collects and batches events on the device
2. Events are sent to Amplitude's servers via HTTP
3. Data appears in Amplitude's analytics platform for analysis

## Key Nomenclature and Definitions

- **Event**: A user action or occurrence tracked in the application
- **User Properties**: Attributes associated with a user that persist across sessions
- **Identify**: API for setting or modifying user properties
- **Group**: A collection of users that can be analyzed together
- **Session**: A period of user engagement with the app
- **Device ID**: Unique identifier for the device, with various lifecycle options
- **User ID**: Custom identifier for a user, typically from your authentication system
- **Revenue**: Monetary transactions tracked within the app
- **Autocapture**: Automatic tracking of predefined events without manual instrumentation
- **Tracking Plan**: A schema defining expected events and properties
- **Flush**: Immediate sending of queued events to Amplitude servers
- **Plugin**: Modular component that extends SDK functionality (in Android-Kotlin SDK)
- **Middleware**: Customization layer for event processing (in legacy Android SDK)

## Key API Endpoints and Methods

### Android-Kotlin SDK

```kotlin
// Initialization
val amplitude = Amplitude(Configuration(
    apiKey = "YOUR-API-KEY",
    context = applicationContext
))

// Event tracking
amplitude.track("Button Clicked", mapOf("buttonColor" to "blue"))

// User identification
amplitude.setUserId("user@example.com")
amplitude.identify(Identify().set("plan", "premium"))

// Group operations
amplitude.setGroup("orgId", "org-123")
amplitude.groupIdentify("orgId", "org-123", Identify().set("plan", "enterprise"))

// Revenue tracking
amplitude.revenue(Revenue().setPrice(3.99).setQuantity(2))

// Manual event flushing
amplitude.flush()
```

### Ampli Wrapper

```kotlin
// Initialization
ampli.load(Context, "API_KEY")

// Strongly-typed event tracking
ampli.songPlayed(
    SongPlayed.Builder()
        .songId("song-123")
        .songName("Bohemian Rhapsody")
        .build()
)

// User identification with Ampli
ampli.identify("user-id", Identify().set("plan", "premium"))

// Flush events
ampli.flush()
```

## Migration Path

The documentation provides a clear migration path from the legacy Android SDK to the Android-Kotlin SDK, including:

1. Updating Gradle dependencies
2. Changing initialization code
3. Updating configuration parameters
4. Mapping API methods between SDKs:
   - `logEvent()` → `track()`
   - `uploadEvents()` → `flush()`
   - `setUserProperties()` → `identify()`

The migration preserves all core functionality while providing access to newer features like enhanced autocapture and the plugin architecture.